<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>White Paper: Web Applications and the PIA</title>
</head><body bgcolor="white" fgcolor="black">
<h2><a href="../index.shtml"><font
face="Verdana, Arial, Helvetica, sans-serif" color="#993300">Ri</font><font
face="Verdana, Arial, Helvetica, sans-serif" color="black"
><i>Source.org</i></font></a>
/ <a href="index.html">White Papers</a>
/ Web Applications and the PIA</h2>

<h3>Foreword</h3>

<blockquote><em>
  This White Paper is intended for web developers: it describes a design and
  development style well-suited to creating customizable Web applications.  
  While this paper discusses development in the context of the PIA technology,
  the fundamental philosophy, which can be roughly characterized as "Web
  application maintenance is mostly a task of document management and should
  not require specialized programming skills or tools," applies equally well
  to other 
  platforms.  Several other technologies, such as Meta-HTML, PHP, and the
  proposed Apache XML initiative, support some of the "active XML" features of
  the PIA.  We encourage the evolution and convergence of these technologies
  to a standard, platform-independent design for Web applications that
  facilitates shared development and ongoing maintenance.
</em></blockquote>

<h3>Contents</h3>

<ol>
  <li> <a href="#web-apps">Introduction: customizable Web applications</a>
  <ol> 
       <li>(automatically generated subheadings -- use html extraction or Docbook?)
  </ol>
  <li> <a href="#pia-approach">The PIA Approach</a>
  <li> <a href="#comparison">Comparison with Other Systems</a>
  <li> <a href="#technical">Technical details</a>
  <li> <a href="#conclusions">Conclusions</a>
</ol>

<h3>Abstract</h3>
<blockquote>
 <p> The World Wide Web has given rise to a new category of applications:
     programs whose primary user interface is a web browser, and which consist
     of a large amount of information or ``documents'' mixed in with a small
     amount of 
     behavior expressed as ``code.''  In effect, applications have become
     specialized web servers.

 <p> Given the ever-changing nature of information and the Web environment,
     easy customization and long-term maintenance should be considered key
     factors for Web application development.  This paper describes an XML
     based design approach and development methodology that supports ongoing
     maintenance while minimizing the need for special technical or
     programming skills.  Most appropriate for applications deployed by
     smaller organizations without significant IT support, these design
     principles are embodied by the Platform for
     Information Applications (PIA).

 <p> PIA based Web applications consist primarily of XML documents written
     using a set of domain specific <a href=glossary.html#tag>tags</a>.
     Maintenance means editing these documents using any standard XML editor.
     The flexible PIA engine serves pages in response to client requests by
     dynamically processing these documents in accordance with developer
     defined semantics.  This processing may include simple tag substitution,
     page transformation, database lookup and insertions, or any other
     functions appropriate to the application domain.  In essence, the tags
     provide a specialized vocabulary available to use in customizing the
     application.
     

 <p> This approach promises platform independent, easily customizable Web
     applications.  XML support in the form of editors and other tools already
     exists on essentially all platforms and continues to grow.  Specifying
     the processing in XML not only makes the logic more accessible but
     restricts the dependence on a particular computing environment to the
     implementation of a few tags. In the PIA, semantics for the small set of
     primitive or "basic" tags are defined in Java, while the majority of
     developer-defined tags are specified in terms of these primitives.
     


 <p> Freely available as open source, the PIA software, written in pure Java,
     is available from <code><a
     href="http://RiSource.org">RiSource.org</a></code> and includes
     interfaces that conform to all relevant standards, including the W3C's
     Document Object Model (DOM), and the Simple API for XML (SAX).
     RiSource.org also distributes and helps coordinate the development of
     PIA-based applications including as a workflow system, shared calendar,
     Web site management tool, and a personal ``browsing assistant.''

<!-- need a good ending here -- perhaps reiterate notion of shared development
     with participation by non-programmers -->

 <p> As an open source project the PIA group welcomes contributions, and we
     are especially eager to receive input from non-programmers.  Naturally,
     contributors will receive <a href="../PIA/Doc/contributors.html">
     public recognition</a> for their work.

<!-- I think the contributors' list belongs in PIA/Doc, since it ought to be
distributed with the code. [steve] -->

</blockquote>


<h2><a name="web-apps">Introduction: customizable Web applications</a></h2>
<h3>What are Web applications?</h3>

<p> The World Wide Web as we know it today represents not one but
    <em>two</em> revolutions in the world of computing.  The first was to
    transform the <em>entire internet</em> into one huge collection of
    documents, each potentially no more than a mouse-click away from any
    other.  The second, less obvious revolution was to transform
    <em>services</em> into collections of <em>active</em> documents.

<p> <strong>A web application is a computing service accessed through the
    web.</strong>  It consists of a web server -- the ``engine'' that makes
    documents available to browsers -- and a collection of documents, some of
    which are ``<em>active</em>,'' i.e. they make the engine ``do things'' for
    the client.

<p> In contrast to ``traditional'' applications, which generally consist of a
    large amount of software associated with a small amount of information
    (or, in some cases, a large database of highly-structured information in a
    small number of varieties), web applications are what Tim O'Reilly has
    called <a
    href="http://www.edventure.com/release1/1198.html#nextgeneration">
    Infoware</a> -- a small amount of software embedded in a large amount of
    (typically unstructured) information.

<p> The new ``killer apps'' are not applications at all like word processors
    or spreadsheets, they are services based upon Web applications -- access to sites
    like <a href="http://www.amazon.com">Amazon</a>, <a
    href="http://www.webvan.com"> Webvan</a>, <a
    href="http://www.commerceone.com"> CommerceOne</a> and <a
    href="http://www.britannica.com/">Britannica</a> <!-- a good example? -->
    is the reason people go out an buy a computer.
    


<h3>Types of Web applications</h3>

<p> Consider five different types of web applications:

<ol>
  <li> <strong><a name="public">Public applications</a></strong>  <br>
       Sites like the ``killer apps'' mentioned above that provide services for
       thousands or even millions of clients around the world.

       <p>

  <li> <strong><a name="enterprise">Enterprise applications</a></strong> <br>
       ``Intranet'' sites, operating <em>inside</em> an organization
       at the enterprise level.  Similar in many ways to public
       applications,  these might include HR systems, procurement systems, and
       other companywide functions.

       <p>

  <li> <strong><a name="group">Group applications</a></strong> <br>
       Applications that serve a workgroup or office.  These include a number
       of common functions such as scheduling or document management systems,
       and ad-hoc functions specific to a particular group e.g. a Web site for
       an architectural design project, job control for a print shop, or
       access to CVS repository for a software development group.  Usually
       accessed over a local network by a small number of users, these
       applications are generally maintained by the members of the group they
       serve, with little or no IT support.

       <p>

  <li> <strong><a name="personal">Personal applications</a></strong> <br>
       Applications used by a <em>single</em> user including
       calendaring and other personal productivity
       functions.  They usually run on a desktop PC, but the web interface
       makes them easily accessible from anywhere on the local network, and
       potentially from anywhere in the world.   (The distinction between
       group and personal applications is a bit blurry  -- personal
       applications generally have a single owner of the data.  These might
       include everything from "MyYahoo" to AvantGo to StarOffice with the
       latter pointing to another area for consideration, "application service
       providers."  We probably want to focus on local applications and put
       things like myyahoo in the category of public sites.  So the examples
       here might be history management.)


       <p>

  <li> <strong><a name="embedded">Embedded applications</a></strong> <br>
       Embedded applications run on an appliance-like device that is not a
       general-purpose computer; examples include printers, scanners,
       facsimile machines, and networked storage devices.  Increasingly, these
       devices are being built with network access and a web-based user
       interface.        

</ol>

<p> Each type of application has different requirements, support, and
    performance 
    characteristics.  Public and enterprise applications must handle large
    numbers of simultaneous users with 24/7 accessibility.  These applications
    generally have full-time staff devoted to their maintenance.  Group
    applications generally have a relatively small number of users but must
    constantly evolve as the information and group needs change.  Embedded
    applications must be very robust and may be deployed in harsh environments
    with no local support.

<p> Existing Web application designs and development
    tools are most appropriate for public and enterprise applications.  These
    applications generally have well-defined software components that are
    developed and maintained by a support group.  In contrast, our design
    methodology seems more appropriate for group applications intended to be
    customized and maintained by the people who use them.  Furthermore, this
    XML based approach provides a safe mechanism for extending and customizing
    applications in the field, a useful feature for embedded applications.  

<p> Before describing our approach in detail, we first review the standard
    technologies and life-cycle for Web applications.

<h3>Technologies for Web Applications</h3>


<p> There are three main ways of making documents on a web site ``active:''

<ol>
  <li> <strong>CGI scripts.</strong> <br>

       This is the ``traditional'' method of building a web application: all
       the actions are performed by programs, ``scripts,'' that are started by
       the server in response to particular URL's.  The script then performs
       any necessary form processing, computes a response, and sends that
       response back to the browser.  The interface between the server and the
       script is the ``Common Gateway Interface'' -- CGI.

  <li> <strong>Servlets</strong> and other server extensions. <br>

       Servlets are little pieces of Java code that the server transfers
       control to in response to particular URL's.  Apart from the fact that
       they run ``inside'' the server rather than as separate processes (and
       hence take much less time to start up), there is little to distinguish
       servlets from CGI scripts.  Similar techniques are used with other
       programming languages, for example C and Perl.

  <li> <strong>Server Pages.</strong> <br>

       This technique involves embedding little bits of code in the web pages,
       to be <em>interpreted</em> by the server.  Typical embedded extension
       languages include Visual Basic (``active server pages''), Perl, PHP, and
       Javascript.  It is also possible to embed scripts in compiled languages
       such as Java (Sun's JSP) -- the pages are compiled offline into
       servlets.  Many servers also provide their own ``mini-languages''
       (Apache's ``server-side includes,'' for example).
</ol>



<h3>The life cycle of Web applications</h3>

<p> In this section we will examine the development ``life cycle'' of a web
    application, and touch briefly on how it differs from that of a software
    application.
</p>

<ol>
  <li> <strong>Initial Development</strong>

  <!-- do we need this section?  We could mention how traditional software
  ends up being 70 percent user interface... -->

       <p> Web applications require a different kind of development than
           traditional software applications.  Software applications have
           always (of necessity) been developed by programmers, sometimes with
           the assistance of a few user-interface designers (all too often
           called in 
           at the last minute to figure out why nobody wants to <em>use</em>
           the new software).  Most interactive applications end up being
           about 70% user interface.
       
       <p> Web applications, on the other hand, typically exceed 95% 
	   ``content'' -- as seen by the user, a web application consists
	   entirely of documents: HTML ``pages'' viewed in a browser.
	   Scattered through these documents are the buttons and text boxes of
	   a more traditional user interface.  

       <p> The
	   developer's perspective depends in part on which technology they
	   choose.  In the early days of the Web, applications consisted
	   primarily of standard HTML documents with a few CGI scripts to
	   handle &lt;form&gt; submissions.  Initial development consisted of
	   creating HTML pages and then creating the CGI scripts to handle
	   specific forms.

       <p> It soon became obvious that this approach was too restrictive since
	   the HTML documents were static and could not reflect updated
	   information.  Morevover, developers grew tired of maintaining the
	   correspondence between the HTML forms and CGI processing.  Servlets
	   and similar technologies solved these problems by generating every
	   page programmatically.  In essence, a method or set of methods is
	   written in your favorite programming language to generate all of
	   the pages that constitute the application.  Applications could be
	   arbitrarily powerful and all the information was contained in a
	   single set of (source code) files making it easier to maintain the
	   correspondence between the (generated) HTML and processing.
	   Development fit very well with traditional software development --
	   generate some specifications and then write software to meet the
	   specifications.

       <p> Eventually developers realized that modifying source code to fix a
	   missing &lt;/table&gt; tag or modify the navigation bar was a
	   tedious job.  Besides that, programming tools do not match very
	   well the linking structure of Web applications.  Server pages
	   provide a compromise solution with regular HTML pages containing
	   bits and pieces of embedded code that the server interprets
	   dynamic.  Developers who are comfortable with the syntax for both
	   HTML and the embedded language can freely intermix the two.  Page
	   layouts and prototype applications can be first developed with
	   static HTML and then augmented with embedded code to provide the
	   desired functions.
	   
       <p> Server pages work reasonably well assuming that all of the
	   developers have similar skill sets, which includes the ability to
	   write in the pages' embedded programming language, and a standard
	   development environment.   Oftentimes though, the embedded
	   programming language makes the documents incompatible with
	   standard structured editors (or the editors produce HTML/XML
	   which breaks the embedded language) and inaccessible to
	   non-programmers.

	   <!-- should have more contrasts later in the paper with templates
	   including explanation of why templates are not extensible or
	   portable -->


       <p> As described in detail below, the PIA approach uses a type of
	   extensible server page.  In contrast with current systems, the
	   embedded ``language'' is pure XML which has several key advantages,
	   such as widespread support from designers and development tools.

       <p>

  <li> <strong>Deployment</strong>

       <p> Once a web application has been developed, it has to be deployed:
	   uploaded to a public server and integrated with the company's
	   existing web site.  Workgroup applications are deployed on an
	   <em>intranet</em> server, but the principle is essentially the
	   same.

       <p> Deployment of a web application is a much more traumatic event than
	   the deployment of a piece of software.  Software's availability can
	   be controlled by controlling its distribution.  It goes first to a
	   select group of beta testers, and only then (after a few rounds of
	   bug fixing and refinement) to wide distribution.  Even after the
	   software ``hits the shelves'' it will take a long time to ``ramp
	   up'' to full deployment.


 <!-- what's the point here?  That rapid customization is needed. -->

       <p> A web application is different.  After it is installed on a
	   public server it may be only a matter of minutes -- days at the
	   most -- before it is found by the search engines, and shortly
	   thereafter by a horde of eager users.  If a public announcement is
	   made, the ``Slashdot effect'' may innundate the server with a
	   ``flash crowd'' -- Britannica's web site was all but inaccessible
	   for a week after its introduction.

       <p> This means that the maintenance cycle is much shorter for a web
	   application than for a software application.  The application's
	   designers may have to respond to problems within minutes, rather
	   than months.  Support for rapid customization is essential.  In
	   effect, what software developers call ``rapid prototyping'' goes on
	   even after a web application is released.

       <p>

  <li> <strong>Maintenance</strong>

       <p> Once a web application has been deployed, the maintenance begins.
	   It has been said that ``software is the only field in which adding
	   a new wing to a building is considered maintenance.''  This is even
	   more true of web applications:  a web site may be completely
	   redesigned and rebuilt several times over its lifetime.

       <p> There are three aspects to maintaining a web application:
	   monitoring the server to ensure that it's operating properly,
	   editing and updating the documents, and modifying the software to
	   keep up with the changes in the documents.

       <p> One of the unpleasant facts of maintenance is that at some point
	   the original developers usually move on to other projects.  This is
	   not a significant problem for the ``content'' portion of a web
	   site: professional writers and designers are good at maintaining a
	   consistent style at an organization.  It <em>is</em> a problem for
	   the application's <em>software</em> -- this is often obscure and
	   poorly documented, and the programmers are usually the first people
	   to move on.

       <p> The software portion of a web application, because it is usually
	   written in ``scripting languages'' like Perl, or is broken up into
	   tiny fragments embedded in the site's documents, is almost always
	   harder to maintain than a traditional all-software application.
	   Sometimes it's easier to scrap it and have a new programming team
	   rewrite large portions, than to figure out some earlier
	   programmer's tricks.

       <p> [!-- support with examples --]

	   [!-- focus on maintenance of server pages --]
       <p>

  <li> <strong>Further Development</strong>

[!-- what's the main point we want to make here?  Who maintains the code, how
       is development shared? --]
       <p> One of the major differences between software and infoware shows up
	   when a design and development team moves on to its next project.
	   The software team's next project is almost certain to be a
	   variation on its previous one -- another compiler, say, or another
	   printer controller.  The team accumulates knowledge, a suite of
	   tools, and a collection of re-useable code that grows with each new
	   project.

       <p> The web design team, on the other hand, is more likely to move on
	   to something very different.  A few basic tools and scripts may be
	   carried over from one project to the next, but most of the content
	   -- the information -- will be new. 

</ol>

<h3>Tools and Methodologies</h3>

<p> Software development is situated somewhere between a craft and an
    engineering discipline, and many design and development tools and
    methodologies exist to assist the process in all of its stages.  Software
    designers may use CASE (Computer Aided Software Engineering) tools;
    programmers can count on syntax-checking compilers, interactive debuggers,
    and even automatic documentation extractors (Javadoc being a recent
    example).  For maintenance there are tools like profilers for improving
    the software's performance, version control systems such as CVS for
    archiving changes, and bug-tracking systems for managing requests.

<p> Even though the linear ``waterfall model'' of the software development
    lifecycle has been partially abandoned, software development is still
    fairly straightforward.  There may be a flurry of ``rapid prototyping''
    while designing the user interface, and major additions may be made during
    maintenance, but on the whole the picture is one of steady progress and
    gradual evolution.

<p> Even in the design phase software is relatively straightforward.  Whatever
    specific methodology is being followed, the application at the end is
    usually fairly close to what the original requirements specified.

<p> Web application design and development are significantly more chaotic.
    Whereas it's almost inconceivable for a software application to start out
    as a compiler and end up as web browser (Emacs may be one of the few
    exceptions), it's not unusual to find a simple search engine that has
    transformed itself overnight into a ``portal site.'' Unlike software
    development, few (if any) methodologies exist to guide this process.

<p> Then again, the tools available for building web applications are still
    very primitive. WYSIWYG editors are good for documents whose ultimate
    destination is ink on paper, but they fail miserably when applied to a web
    page that may be viewed on anything from a Palm Pilot to a 21-inch
    monitor.  There is little if any support for complex operations like
    changing the header and footer of every document on a web site.  There's
    no support at all for editing documents that may contain bits of scripting
    mixed in (especially if some of it is meant for the browser and some for
    the server, in two different languages).

<!-- proprietary application platforms to support sophisticated Web
    application development -- e.g. cold fusion -->

<p> A few proprietary platforms exist, for example Cold Fusion, that support
    sophistecated Web application development.  Unfortunately these tend to
    be very expensive, have their own nonstandard programming component, and
    of course lock the designers in to a single vendor.

<!-- more needed? SS -->

<h3>Customization</h3>

<p> The largest problem facing a workgroup or small business is
    <em>customizing</em> their web applications.  An enormous amount  of
    effort can go into designing and maintaining a public or enterprise-level
    web site, but the project has the full support of the company's IT
    department, a large budget for designers and consultants, and so on.
    Since the revenues from a public web application are likely to be large
    (they may even be the company's <em>only</em> revenue stream, as in the
    case of an Internet-based business), it's easy to justify a large
    expenditure.  Similarly, an enterprise-wide intranet site is going to be
    run by the IT and HR departments, which can easily justify its cost.

<p> The situation is far different in a workgroup or small office.  The
    software complexity of the application is likely to be almost as great as
    that of a large public web site, but the amount of <em>information</em>
    associated with it is far less, and there may not be even a single
    full-time person dedicated to maintaining the entire network, let alone
    the web applications that make it useful.

<p> As a result, small-scale web applications are usually ``home-grown'' in
    somebody's spare time.  (They might be bought ``off the shelf,'' but
    shrink-wrapped web applications are exceedingly rare at this point.)  They
    will tend to grow haphazardly, as the result of a series of customizations
    to meet the group's changing requirements.  Of course, it's almost trivial
    to customize the <em>information</em> part of a small web site.  The
    software is another matter, and will often consist of small CGI scripts
    downloaded from the Net and changed as little as possible.

<p> Web applications that are built using extensible server pages (for
    example, ASP, JSP, PHP3, and Meta-HTML) tend to be easier to customize
    than those based on standard programming techniques such as CGI scripts or
    servlets.  The PIA's approach to extensible server pages is particularly
    simple because, being XML-based, it is well adapted to existing authoring
    tools and techniques.

<p>

<hr>
<h2><a name="pia-approach">The PIA Approach</a></h2>

<p> The PIA is a highly versatile platform for web applications:  it is able
    to function as either a ``traditional'' web <em>server</em>, a
    <em>client</em>, or a <em>proxy</em>.

<ul>
  <li> As a server, the PIA provides a simple platform for form-processing
       applications.  All of the PIA's special tags are interpreted on the
       server: the browser sees nothing but ordinary HTML.  But because the
       PIA's tags have the same syntax as HTML and XML tags, PIA-based
       applications can be developed and modified using the tools all web
       developers are already familiar with.

  <li> As a client, the PIA can download and process pages from other web
       sites.  For example, this can be used for ``portal'' applications that
       fetch and reformat news items and stock prices.  The PIA includes a
       facility for performing an action at specified times or intervals,
       which can be used for updating.

  <li> The most unusual use of the PIA is as a proxy, situated
       <em>between</em> a user's browser and the Web.  In this mode it can
       operate as a kind of ``surfer's assistant.''  It can, for example, keep
       a permanent browsing history, block access to certain sites, or reformat
       pages for display on a palmtop.
</ul>

<p> Furthermore, the PIA can <em>combine</em> these aspects, enabling totally
    new kinds of web applications.  The PIA approach to web applications is
    based on three main ideas, which we will examine in more detail below:

<ol>
  <li> <a href="#dps">Server-side document processing</a>
  <li> <a href="#site">Flexible server configuration</a>
  <li> <a href="#agents">Agents and event-based processing</a>
</ol>

<h3><a name="dps">The PIA's Document-Processing System</a></h3>

<p> The PIA's server-side document processing system (DPS) is essentially a
    form of extensible server pages, with three main differences from other
    systems.

<ol>
  <li> The syntax of the extensions is <em>pure</em> XML or HTML -- there are
       no constructs like assignment statements or arithmetic expressions.
       This means that documents can be created, edited, and processed using
       existing tools.  It also means that the PIA's processing feels more
       like document processing and formatting than like programming.

  <li> <em>None</em> of the tags in a PIA document has a fixed meaning.  This
       allows the PIA to, for 
       example, take <em>ordinary</em> HTML documents and apply
       ``styles'' or other processing to them.  The processing
       instructions -- the semantics -- of the tags are usually specified in a
       separate document which we call a <em>tagset</em> (itself an XML
       document).  The configuration files associate particular classes of
       documents with particular tagsets (can also be done dynamically).  Of
       course, tag definitions and processing
       instructions can also be embedded directly in a document.  

  <li> The PIA's document processing deals with <em>parse trees</em>, not
       strings (text).  Every syntactically correct document can be
       represented by a ``tree structure'' in which every start tag has a
       matching end tag, all start and end tags are properly nested, and so
       on.  Getting this structure correct is easy to do in a WYSIWYG HTML or
       XML editor, but not in most programming languages -- in particular it's
       perfectly feasible for any of the other systems to send an incorrect
       page to the browser, which may then do unpredictable things with it.
       This can't happen in the PIA.
</ol>

<p> The way the PIA works, by ``expanding'' defined tags, is shown in
    the following sample:

<p> <img src="/images/sample.png"/>

<p> Let's examine some of the consequences of these features in more detail:

<ul>
  <li> <strong>XML-based processing.</strong>

       <p> The PIA is XML ``all the way down'' -- there are no other
           programming constructs that have to be learned.  This means that
           existing XML and HTML editing tools can be used, and will be able
           to <em>help</em> an author deal with the extensions rather than
           getting in the way or, worse, rejecting the extensions because they
           don't follow correct XML syntax.

       <p> Moreover, the PIA's document processing <em>uses</em> the nested
	   tag structure of documents, rather than ignoring it.  It is
	   impossible for the PIA to create a syntacally incorrect document.
	   Also, XML can be used for its intended purpose as structured data:
	   the PIA's tags include powerful data extraction and tree
	   transformation operations.

       <p> The end result is that all of a web application's data can be kept
	   in the form of XML files, if desired.  And because XML can be
	   embedded directly in ordinary HTML pages, there is no artificial
	   barrier between information and processing: a single document can
	   include both, <em>with the same syntax</em> in the same familiar
	   markup-language style.

       <p>

  <li> <strong>Dynamic tagsets.</strong>

       <p> A <em>tagset</em> is an XML document that assigns meanings to tags.
	   In most cases, these meanings are similar to ``macros:'' they
	   simply specify a piece of text (and tags, of course) that replaces
	   the defined tag.  Tagsets allow the designer to collect all of an
	   application's special-purpose tags in a single document; imposing a
	   uniform style by ``cut-and-paste'' becomes a thing of the past. 

       <p> A small number of tags are pre-defined as ``primitives.''  They
	   define a Turing-complete scripting language on which a user can
	   build complete applications.

       <p> Several pre-defined extensions of the basic tagset are provided,
	   for applications that include document formatting, calendaring,
	   office form processing, and web site content management.  Tagsets
	   provide applications with a domain-specific vocabulary for document
	   structuring and processing. 

       <p> Because the tagset is separate from the document being processed,
	   it is possible to process the <em>same</em> document in different
	   ways.  This can be as simple as changing the appearance of a
	   document's page headers and footers in different parts of a web
	   site, or as complex as a site indexing package.

       <p> It is also possible to obtain documents from <em>other</em> sites
	   and process them to obtain information.  For example, a workgroup
	   site might display the current price of the parent company's stock.
	   A personal productivity application might download and merge e-mail
	   from multiple web-based mail sites.

       <p> Many web sites and applications use specialized XML documents for
	   transferring information; it is easy to process these using a
	   special-purpose tagset. 

       <p> Tags have also been designed that allow HTML documents to be
	   ``updated in place'' in response to user input.  This technique is
	   especially useful for discussion forums, as well as in certain
	   kinds of form-based applications.

       <p>


  <li> <strong>Entities and Namespaces</strong>

       <p> XML defines a construct called an ``entity'' (the familiar
	   <code>&amp;</code> construct for coding an ampersand in HTML is one
	   example) that allows arbitrary text to be effectively ``included''
	   in a document.  The text of an entity can be defined as part of a
	   document type declaration, or it can be specified as coming from a
	   file or even an arbitrary URL.

       <p> The PIA permits entities to be treated the way other programming
	   languages treat ``variables'' -- they can be written into as well
	   as inserted, and so can change dynamically while a document is
	   being processed.  Entities that reside in files provide a simple
	   mechanism for making data ``persistant'' and for sharing data among
	   the documents that make up an application.

       <p> The PIA also extends XML's notion of ``namespaces'' to impose a
	   directory-like hierarchical structure on entities.  This gives rise
	   to entity names like ``<code>&FORM:inputVar;</code>'' and
	   ``<code>&DOC:path;</code>'' -- the value of the "inputVar" variable
	   submitted as part of a form, and the path <em>from</em> the
	   server's URL to the document itself.

       <p>


  <li> <strong>Security</strong>

       <p> The tags available for use while processing a document are limited
	   to those provided by the tagset.  Although the PIA's tags include
	   operations for accessing other web sites, for reading and writing
	   files, and for controlling the application, it is easy to
	   <em>remove</em> any subset of these tags before processing a
	   document that might be ``suspect'' in any way (for example, when
	   processing a document from foreign site or an incoming e-mail message).

       <p> Of course, since a PIA-based application is a web server, it is
	   also possible to use standard web authentication techniques such as
	   passwords.  The PIA's tags also include operations for computing
	   and verifying digital signatures.

       <p> The ability of the application designer to specify exactly what set
	   of operations an active document can perform makes it possible to
	   be much more secure than a system in which arbitrary code can be
	   embedded in a document, or (horrors!) even downloaded on request
	   (as applets and ActiveX controls are on the browser side).

       <p> Because the exensions in a document are XML, and hence visible as
	   part of the document's structure, it is also possible to ``audit''
	   a document, or even an entire new application, to ensure that it
	   does nothing unsafe or unexpected.  Naturally, this can easily be
	   done by means of a tagset.

</ul>

<p> The operation of the PIA's document-processing system is described further
    in a companion White Paper, <a href="wp-dps.html">Document Processing in
    the PIA</a>.  The PIA's documentation can be found online at <a
    href="../PIA/Doc">../PIA/Doc</a>.  There are several features of the PIA,
    including its flow-through architecture and its use of open API's, that
    are of interest for other areas besides customizable Web applications.

<!-- mention other interesting properties like flow-through that might be
interesting for other aspects of development but not germane to customizable
Web applications -->




<h3><a name="site">Flexible site configuration</a></h3>

<p> Like most web servers, the PIA has a configuration file in which all of
    its many options and parameters can be specified.  Also like most servers,
    additional configuration files can be supplied in any directory to supply
    <em>local</em> options.

<p> Unlike other servers, however, the PIA's configuration files are pure XML
    (which should come as no surprise), and any of the standard
    document-processing tags can be used in them.  In particular, the
    <code>&lt;include&gt;</code> tag can be used to include other files (for
    example, the standard mappings for filename extensions), and the
    <code>&lt;if&gt;</code> tag can be used to make parts of the configuration
    optional (for example, setting up authorization only if a password file
    can be found).

<p> Three aspects of the site configuration mechanism are particularly
    interesting: 

<ol>
  <li> <strong>Shadow Directories</strong>

       <p> The PIA has a mechanism that allows two directories to be
           ``overlaid'' on top of one another.  The one ``on top'' is the
           <em>real</em> directory, and any files the PIA <em>writes</em> go
           into it.  The one ``underneath'' is called the <em>virtual</em>
           directory, and the PIA looks there for any file it can't find in
           the real one.

       <p> Although this seems confusing at first, it makes local customization
	   <em>enormously</em> easier.  For one thing, it gives greatly
	   increased protection to the PIA's own files, and to an
	   application's documents.  Usually an application is shipped with
	   a configuration file that puts all of its documents in a virtual
	   directory.  Any local <em>customizations</em> then go into the real
	   directory.  The virtual directory might even be on a CD-ROM, or in
	   some location shared by many users, each with their own real
	   directory full of personal data and customizations. 

       <p>

  <li> <strong>Virtual Documents</strong>

       <p> The same configuration mechanism that allows for shadow directories
	   can also be used to make ``virtual documents'' appear in a
	   directory.  The main use of this is to create ``aliases'' or
	   ``symbolic links'' in an OS-independent way:  the virtual document
	   or directory can be brought in from anyplace on the system.

       <p>

  <li> <strong>Extension Mappings</strong>

       <p> The configuration file also defines the mapping between filename
	   extensions and both MIME types and tagsets.  It is also possible to
	   <em>hide</em> files from the client; hidden files can still be
	   accessed from inside the applicaton.

       <p> The extension mapping also defines a ``search order'' -- a URL
	   without an extension causes the PIA to try each of the listed
	   extensions in order until a document is found.  Among other
	   advantages, this means that document names in URL's don't need
	   extensions, making them shorter and easier to type and remember.

       <p> A further advantage of omitting extensions is that a document's
	   extension, and hence the tagset that processes it, can be changed
	   at any time by the application designer without invalidating a
	   user's bookmarks. 

</ol>

<h3><a name="agents">Agents and event based processes</a></h3>

<p> The PIA also serves as a platform for running software <em>agents</em>.
    These are small XML documents that specify actions to be performed in
    response to <em>events</em> rather than specific client requests.  In this
    role the PIA is sometimes referred to in its documentation as an
    ``agency.''

<p> There are several uses for agents, corresponding to different kinds of
    events that activate them.

<ul>
  <li> <strong>Chronological agents</strong>
       
       <p> These are activated at a particular time, or repeated at a
	   particular interval.  For example, one can specify that a
	   particular agent is supposed to run daily at 1am, or every hour on
	   the half-hour.  This kind of agent is similar to a
	   ``<code>cron</code> job'' or ``<code>at</code> job'' in Unix; they
	   can be used for reminders, periodic updates, cache management, and
	   so on.

       <p>

  <li> <strong>Transaction agents</strong>

       <p> Transaction agents are activated by specified features of web
	   requests or responses.  They can then operate on the transaction
	   and, for responses, on the document itself before it gets to the
	   client.  One of the earliest uses of a transaction agent was one
	   that maintains a permanent browsing history.  A closely related one
	   puts a small ``toolbar'' at the front of every HTML page requested
	   using the PIA as a proxy.  A more recent application was an
	   ``ad-buster'' agent that recognizes requests to banner-ad sites and
	   redirects them.  

       <p> Some of the things that can be done with transaction agents
	   resemble other innovative proxy-based web applications, for example
	   IBM's WBI, or with specialized web caching software.

       <p>


  <li> <strong>Marker agents</strong>

       <p> Marker agents don't really respond to <em>any</em> events, they
	   just ``bookmark'' their ``home URL,'' which is typically an
	   application.  This gives the user a ``short cut'' URL for that
	   application, for example ``<code>/~Calendar</code>'' instead of the
	   more verbose ``<code>/Agents/SimpleCalendar</code>''.  The use of a
	   tilde on the agent's name is meant to resemble the common
	   convention of using a tilde in the URL for a user's home directory
	   on Apache and similar web servers.  In some cases, marker agents
	   might be set up for <em>real</em> users on a group site.

</ul>

<p>

<hr>
<h2><a name="comparison">Comparison with Other Systems</a></h2>

<p> In this section we will compare the PIA's approach to constructing web
    applications to that of other systems currently in use. 

<h3>Conventional platforms</h3>

<!-- we already discussed the conventional platforms of separate code; may
be just introduce PHP, Meta-HTML as examples that we compare in detail -->

<p> The conventional platforms for web applications break down into two broad
    categories:  separate code, and embedded code:

<ol>
  <li> <strong>Separate code</strong><br>

       Systems that separate code from include CGI scripts, Apache modules,
       Java servlets, and so on.  All require considerable programming skills
       in order to change or customize the behavior associated with an
       application's document.  All have the additional disadvantage that,
       because code and data are in separate files, it is easy for changes in
       a document to ``break'' the associated code.  Modules and servlets also
       pose the risk of a bug in the code causing a server crash.

       <p>

  <li> <strong>Embedded code</strong><br>

       Systems that embed code in documents include ASP (Visual Basic) and JSP
       (Java); similar systems exist for embedding other languages, including
       shell scripts (Apache server-side includes), Perl and Python.  All
       still require a certain level of programming skill, with at least
       passing familiarity with a programming or scripting language and its
       syntax.  Editing tools designed for HTML and XML give little or no
       assistance when editing the embedded scripts.
       
</ol>

<p> It is difficult, using embedded languages, to perform processing on
    arbitrary documents.  It is almost impossible to use them to define new
    tags, or new meanings for old tags. 


<h3>Server-side extension languages</h3>

<p> Server-side extension languages are complete programming languages that
    are designed to generate web pages; in general ordinary text and HTML tags
    are treated as ``constants'' and passed through to the client.
    <!-- wrong meaning?? , much as they are in the PIA.  -->
    The PIA falls squarely in this category, but with some significant
    differences which we will examine in more detail below.  For the moment,
    let's compare the PIA to two well-known server-side languages, Meta-HTML
    and PHP.

<ul>
  <li> <strong><a href="http://www.metahtml.com/">Meta-HTML</a></strong><br>

       is similar in spirit to the PIA's language, and looks very similar at
       first glance.  It can be thought of as a ``LISP-like'' programming
       language that uses angle brackets instead of parentheses.  The problem
       with this approach is that, because angle-bracketed constructs can be
       nested (including inside of regular tags and attributes), Meta-HTML
       pages do not adhere to XML or HTML syntax, and so cannot be edited by
       standard tools.  It <em>is</em> possible to use Meta-HTML to define new
       tags and embed them in regular HTML.

       <p>


  <li> <strong><a href="http://www.php.net/">PHP</a></strong><br>

       is actually an ``embedded code'' approach.  PHP scripts, written in a
       language that somewhat resembles Perl, are enclosed in
       <code>&lt;?php&nbsp;...&nbsp;?&gt;</code> brackets that make them look
       like XML ``processing instructions.'' (Other bracketing methods exist,
       but this is the most ``XML-friendly.'')  PHP, then, has all the usual
       disadvantages of embedded code with respect to editing tools, but at
       least the embedded constructs are designed so that they can be properly
       ignored or passed through by XML tools.  It would not be difficult for
       PHP and the PIA to co-exist; for example, PHP could be used inside of
       tagsets, or an application could consist of a mixture of XML and PHP
       documents.  

       <!-- e.g. PHP in the tagset -->

</ul>



<table border=3 align=center cellpadding=2>
<thead>
 <tr><th>Feature</th><th>Meta-HTML</th><th>PHP3</th><th>PIA</th></tr>
</thead>
<tbody>
 <tr><th align=left>Syntax</th>
     <td>HTML-like</td>
     <td>C-like</td>
     <td>pure XML</td>
 </tr>
 <tr><th align=left>Embedded processing</th>
     <td>yes</td>
     <td>yes</td>
     <td>yes</td>
 </tr>
 <tr><th align=left>Tagsets</th>
     <td>yes</td>
     <td>no</td>
     <td>yes</td>
 </tr>
 <tr><th align=left>redefine document tags?</th>
     <td>yes</td>
     <td>no</td>
     <td>yes</td>
 </tr>
 <tr><th align=left>treats documents as:</th>
     <td>strings</td>
     <td>strings</td>
     <td>parse trees</td>
 </tr>
 <tr><th align=left></th>
     <td></td>
     <td></td>
     <td></td>
 </tr>
</tbody>
</table>


<p> Neither Meta-HTML nor PHP, nor any other server-side scripting system that
    we know of, shows any awareness of the structure of the underlying
    document.  The document is simply treated as a ``character string;'' it is
    possible to generate syntactically incorrect documents, and it is
    not particularly easy to manipulate the document's parse tree.  This makes
    it difficult to take advantage of the document's structure. 

<!-- expand this section -- why is it important? -->


<p> PHP <em>does</em> include an XML parser, which can be used for processing
    documents, but it can't handle ordinary HTML.  Unlike Meta-HTML, PHP lacks
    the notion of tagsets.


<h3>XML-based approaches</h3>

<p> The available XML-based approaches to server-side document processing fall
    into two broad categories:  embedded code inside of XML constructs (like
    PHP), and ``style-sheet'' languages.  As we will see, the PIA, which is
    <em>also</em> XML-based, has aspects of both.

<ul>
  <li> <strong>XSL</strong><br>

       is essentially a translation of a subset of the W3C's ``cascading style
       sheet'' language into XML.  An XSL style sheet is a set of rules that
       can be applied to a document to transform it, usually for presentation.
       Unfortunately XSL is not a complete language, and it cannot be embedded
       in a document -- it is applied from the ``outside'' like processing
       with a tagset.  

       <p>

  <li> <strong>DSSSL</strong><br>

       is an older standard for processing SGML documents.  Unlike XSL, it
       <em>is</em> a complete programming language, being based on a variant
       of Scheme.  On the other hand, it does <em>not</em> have XML syntax,
       and shares XSL's inability to be embedded in a document.  It would
       probably be possible, though, to <em>implement</em> the PIA's tag
       language as a DSSSL style.

</ul>

<p> The main disadvantage of the style-sheet languages is that they cannot be
    embedded in a document.  In addition, they tend to be difficult to learn,
    and cannot easily be manipulated as data.  XSL, and the closely related
    Cascading Style Sheets of HTML, are not complete programming languages.
    We feel that <em>both</em> expressive power and embeddability are
    important.  It's worth noting, though, that style-sheet processing could
    easily be added to the PIA's document processor. 

<p>

<table border=3 align=center cellpadding=2>
<thead>
 <tr><th>Feature</th><th>XSL</th><th>PIA</th></tr>
</thead>
<tbody>
 <tr><th align=left>local transformations</th>
     <td>no: assumes a complete parse tree</td>
     <td>yes: documents can be streamed</td>
 </tr>
 <tr><th align=left>arithmetic operations</th>
     <td>counters only</td>
     <td>yes</td>
 </tr>
 <tr><th align=left>text manipulation</th>
     <td>sorting and concatenation</td>
     <td>sort, split, join, trim, subst</td>
 </tr>
 <tr><th align=left>iteration</th>
     <td>only over node sets</td>
     <td>general</td>
 </tr>
 <tr><th align=left>tests</th>
     <td>tree matching</td>
     <td>numeric, string</td>
 </tr>
 <tr><th align=left>embedded expressions</th>
     <td><code>{<em>xpointer</em>}</code></td>
     <td><code>&amp;<em>entity</em>;</code></td>
 </tr>
 <tr><th align=left>definitions</th>
     <td>only in stylesheet</td>
     <td>tagset or document</td>
 </tr>
 <tr><th align=left>processing</th>
     <td>only in stylesheet</td>
     <td>tagset or document</td>
 </tr>
 <tr><th align=left>native code extensions</th>
     <td>no</td>
     <td>yes, through tag handlers</td>
 </tr>
 <tr><th align=left>interface to files</th>
     <td>read-only</td>
     <td>read/write</td>
 </tr>
 <tr><th align=left>interface to web docs</th>
     <td>read-only</td>
     <td>read/write/query</td>
 </tr>
 <tr><th align=left>interface to server</th>
     <td>no: documents only</td>
     <td>yes: can operate on transactions</td>
 </tr>
 <tr><th align=left>interface to database</th>
     <td>no</td>
     <td>yes</td>
 </tr>
 <tr><th align=left>&nbsp;</th>
     <td>&nbsp;</td>
     <td>&nbsp;</td>
 </tr>
 <tr><th align=left>Learnability</th>
     <td>complex</td>
     <td>simple</td>
 </tr>
 <tr><th align=left>Security</th>
     <td>N/A</td>
     <td>flexible</td>
 </tr>
</tbody>
</table>

<hr>
<h2><a name="technical">Technical details</a></h2>

<p> A full technical analysis of the PIA is beyond the scope of
    this paper.  Here we mention a few of the technical aspects of
    the PIA's implementation that have direct consequences for the designer of
    web applications.

<h3>Performance and portability</h3>

<blockquote>
<p> Currently the PIA is highly portable, but fairly large and not
    particularly fast; this makes it most suitable for personal and group
    applications.  We are actively working on the size and speed problems,
    with the ultimate goal of developing a much faster and smaller version
    that can easily be integrated with Apache and other high-end web servers. 
</blockquote>

<!-- make clearer what is the state of the world today and what we would like
to be tomorrow, especially integration of key features into apache/PHP, etc. -->

<p> The PIA is currently written in Java, which makes it highly portable; it
    is known to run under Sun's JDK 1.1 and 1.2 on Linux, Solaris, and Windows
    98 and NT, as well as under Kaffe on Linux.  Adding to the PIA's
    portability is the fact that the user interface is completely web-based,
    avoiding Java's user interface classes.

<p> Unfortunately, Java is an interpreted language, which imposes a
    performance penalty.  There are several factors in the PIA's design which
    partially compensate for this:

<ul>
  <li> The DPS ``processing engine'' does not build large data structures in
       memory.  It is possible to ``stream through'' the parts of a document
       that do not need to be further processed.  As a result, the PIA's
       memory ``footprint'' is comparatively small, and it runs fairly
       quickly.

  <li> XML and HTML are very efficient to parse:  parsing can be done with a
       simple state machine, avoiding recursion and backtracking.  This can
       result in a significant time saving.

  <li> The PIA's site configuration manager ``caches'' all site configuration
       information, including all tagsets and shared entities, in memory.
       Since one of the most expensive operations on a web server can be
       opening files and searching directories, this results in a considerable
       saving.

  <li> Static pages, including plain HTML and images, need no processing, and
       can be passed through the PIA untouched.  It is also possible to use a
       different server, such as Apache, to invisibly serve static pages.

  <li> It is possible to run the PIA's document processor from a command line
       or <code>makefile</code> to process documents ``offline.''  Only the
       truly dynamic pages need to be processed by the server. 
</ul>

<p> <em>In its present Java implementation</em>, the PIA is not well suited
    for large public websites or other applications where extreme high
    performance is needed.  At least, <em>not yet.</em> There are three
    possible ways of improving the PIA's performance dramatically:

<ol>
  <li> <strong>Full compilation</strong><br>
       Some Java compilers exist that can produce machine-language
       applications instead of interpreted ``byte codes.''  These have their
       limitations, but nothing would prevent using one to give the PIA an
       immediate performance boost.

       <p>

  <li> <strong>Conversion to C.</strong><br>
       Because the PIA's document processing engine is based on a small number
       of primitive tags, it would be quite simple to rewrite it in another
       programming language.  C is the obvious choice: it is universally
       available, easily interfaced with other web servers, and delivers very
       high performance.  (See RiSource.org for status of the conversion
       effort.) 

       <p>

  <li> <strong>Document format conversion.</strong><br>
       Although XML is easy to parse, it's not completely trivial.  The PIA
       imposes an additional step, namely looking up the action associated
       with each tag.  A ``pre-parsed'' binary document format would eliminate
       this step, and possibly speed up text searches as well.  The ultimate
       extension of this, which has the potential to deliver the
       <em>ultimate</em> in performance, would be to <em>compile</em> pages
       into C programs.  Running such a program would perform any necessary
       processing, and send the resulting page directly to an output stream.

</ol>

<h3>Server integration</h3>

<p> In order to integrate PIA-based applications into an existing web site,
    it is usually necessary to integrate the PIA with the server that is
    already present.  There are three ways of doing this:

<ol>
  <li> <strong>Proxying</strong><br>

       Apache has a technique for seamlessly integrating another web server
       into a website; this is done by adding a single line to Apache's
       configuration file.  Apache will invisibly proxy requests to selected
       sub-directories to the other server.  The PIA server can then be
       configured to run on a different port from Apache's, but to report
       Apache's port to the browser when constructing a URL.  This technique
       allows portions of a website to be served by the PIA, and the rest by
       Apache. 

       <p>
       
  <li> <strong>Servlets</strong><br>

       Java servlets are a common, standardized technique for including active
       documents into a web server.  Since the PIA is written in pure Java,
       it's easy to wrap a servlet interface around the PIA's web-server
       engine. 

       <p>
       
  <li> <strong>Modules</strong><br>

       Apache has an extremely powerful extension technique in which
       ``modules'' -- essentially shared libraries with a standard interface
       -- are linked in with the main server.  Many of Apache's standard
       functions are already implemented in this form, as are several existing
       extension languages such as PHP.  By rewriting the PIA's
       document processing and site-structuring subsystems in C, it will be
       possible to integrate the PIA into Apache as a module.
<!-- necessary? -->
       When complete,
       this effort will give the tightest integration and the highest
       performance.

       <p>

  <li> <strong>Offline Processing</strong><br>

       As we mentioned above under ``performance,'' it is possible to process
       documents outside of the server environment.  If a web site consists
       entirely of static pages, it is possible to use the PIA's document
       processing purely as a formatter and have the existing server deliver
       the resulting static pages.

       <p>

</ol>

<h3>Integration with other applications</h3>

<p> It is just as easy to integrate the PIA with existing applications,
    web-based and otherwise, as it is to integrate it with a web server.  As
    usual, there are several ways of doing this:

<ul>
  <li> <strong>HTTP</strong><br>

       Integrating the PIA with <em>web-based</em> applications is trivial.
       Since the PIA has tags that allow it to make HTTP requests, a PIA
       application can easily and seamlessly call on other web-based
       applications or devices for services.

       <p>

  <li> <strong>Local programs and files</strong><br>

       A mechanism exists for the PIA to run local programs, in any language,
       as CGI scripts.  Since it can also read and write files, it can prepare
       input and analyze output from local applications as well.

       <p>

  <li> <strong>Custom primitive tags</strong><br>

       It is easy for a programmer to write custom ``handlers'' for
       special-purpose tags, and add these to a PIA application.  Interfaces
       to special-purpose hardware and legacy databases have already been
       developed in this form.  The PIA's tags for date and time computation
       and for generating digital signatures were originally custom handlers
       that later became part of the basic system.

<!-- example of legacy database access -->
       <p>

  <li> <strong>Standard API's</strong><br>

       The PIA's document-processing subsystem uses standard API's, including
       the W3C's Document Object Model (DOM) for representing documents as
       parse trees, and the Simple API for XML (SAX) for communication between
       parsers and applications.  SAX is particularly useful because the DPS
       can be made to look like <em>either</em> a SAX parser, a SAX
       application, or both.  In addition, tags have been written that use the
       JDBC interface to communicate with a database.
</ul>


<h3>Embedded applications</h3>

<p> We expect one of the major uses of the PIA to be ``embedded''
    applications, with the PIA providing the primary user interface for some
    piece of equipment that is <em>not</em> a general-purpose computer.  There
    are several features of the PIA that make it suitable for embedded
    applications.

<ul>
  <li> <strong>Small memory footprint</strong><br>

       Because of the PIA's efficient, ``pass-through'' document-processing
       architecture, it is fairly compact.  The Java version occupies about
       16Mb, including the Java run-time; we expect the C version to do
       <em>significantly</em> better.

       <p>

  <li> <strong>Ease of integration</strong><br>

       Because of the simplicity of special-purpose tag handlers, it is easy
       to integrate the PIA with any special-purpose hardware or software
       services on the appliance.

       <p>

  <li> <strong>Ease of customization</strong><br>

       The PIA makes it possible for a user or group of users to customize an
       appliance by editing documents, rather than by installing software.  It
       is widely recognized that incompatibilities and bugs in installed
       applications are the major contributor to the unreliability of PC
       software, so this represents a major advantage for PIA-based
       appliances.

       <p>

  <li> <strong>Security and safety</strong><br>

       The PIa's tagsets make it ideal for use on appliances that store or
       process documents, since it's easy for the application to ensure that
       all effects of the processing are confined to the document itself.

</ul>


<p>

<hr>
<h2><a name="conclusions">Conclusions</a></h2>


<h3>What's Important about the PIA approach?</h3>


<p> We have seen that the PIA offers what appears to be a unique combination
    of features:
<ul>
  <li> Turing-complete, XML-syntax document-processing language
  <li> Embedded <em>or</em> separate (style-like) processing
  <li> Web client/server/proxy platform based on agents
</ul>

<p> The following table goes into a little more detail:

<p>
<table>
 <tr><th colspan=2 align=left> Server-side Document Processing </th></tr>
 <tr><td valign=top><em>XML-compliant</em></td>
     <td> Standard tools (editors, parsers, etc.) can be used for
	  development.  Processing can be separate or embedded in documents.
     </td> 
 </tr>
 <tr><td valign=top><em>Embeddable</em></td>
     <td> Documents can contain their own processing, embedded in the portion
	  of the document that has to be processed.
     </td>
 </tr>
 <tr><td valign=top><em>Separable</em></td>
     <td> Separate tagsets can be shared among documents.
     </td>
 </tr>
 <tr><td valign=top><em>User-extensible</em></td>
     <td> User-Defined tags have the same syntax as built-in operations.
     </td>
 </tr>
 <tr><td valign=top><em>Operates on parse trees</em></td>
     <td> Impossible to generate a syntactically-incorrect output document.
     </td>
 </tr>
 <tr><td valign=top><em>Small set of primitives</em></td>
     <td> Easily ported to other programming languages.  Easy to learn.
     </td>
 </tr>
 <tr><td valign=top><em>Efficient</em></td>
     <td> Documents can be streamed through, meaning that the browser can get
	  the first part of a page while the rest is still being generated.
     </td>
 </tr>

 <tr><th colspan=2 align=left> Web-based application platform </th></tr>

 <tr><td valign=top><em>Flexible configuration</em></td>
     <td> Active documents and data easily separated, but can be shown in the
	  same URL tree.
     </td>
 </tr>
 <tr><td valign=top><em>XML configuration files</em></td>
     <td> Full power of document-processing language available at
	  configuration time.
     </td>
 </tr>
 <tr><td valign=top><em>Java-based</em></td>
     <td> Platform-agnostic.  Runs on Linux, Unix, Windows.
     </td>
 </tr>
 <tr><td valign=top><em>Agent-based event handling</em></td>
     <td> Processing can occur based on transaction features (request and
	  response headers) or time.  Agents can modify transactions.
     </td>
 </tr>
 <tr><td valign=top><em>Client / Server / Proxy</em></td>
     <td> Web engine operates in multiple modes for maximum flexibility.
     </td>
 </tr>

</table>


[!-- what features are necessary for shared development, customization, and
maintenance.  platform independence]


<h3>Would the PIA be useful for <em>your</em> web application?</h3>

<!-- Not sure what the best organization for this section is.  Maybe just
present the strongest case for PIA adoption (e.g. group application) and then
argue for adoption of particular features in other development areas? -->

<ul>
  <li> <strong><a href="#group">Group applications</a></strong> <br>

       This is the archetypal application area for the PIA.  If you're
       building a web-based workgroup or small office application, especially
       one that is going to be customized by group members without programming
       skills, the PIA may be almost ideal.

       <p>

  <li> <strong><a href="#personal">Personal applications</a></strong> <br>

       This is another area where the PIA has enormous potential.  Since the
       PIA is highly portable it can run on almost anyone's desktop; since
       PIA-based applications are <em>designed</em> to be easily customized,
       every user can personalize and improve their own environment.  Also
       consider systems in which <em>both</em> personal and workgroup PIA's
       are present and interacting, or in which a personal PIA interacts with
       web-based appliances. 

       <p>&nbsp;</p>

       <p>


  <li> <strong><a href="#public">Public web sites</a></strong> and
       <strong><a href="#enterprise">Enterprise applications</a></strong> <br>
       
       The PIA's offline document processing can be a powerful tool for
       organizing a public web site, and a personal PIA server is almost ideal
       for quickly previewing a site.  The PIA can also be integrated with an
       existing server for form handling.  Currently, however, the performance
       is not up to serving a high-traffic site and the security, while
       potentially high, is still unproven.  In the more protected enterprise
       environment, a PIA-based server could be a useful <em>adjunct</em> to a
       site, serving as a platform for a subset of the site's applications.
       As the PIA's performance improves and it becomes better-integrated with
       servers such as Apache, we expect it to become more useful at this
       level as well.

       <p>

  <li> <strong><a href="#embedded">Embedded applications</a></strong> <br>

       Until the C version of the PIA is completed, the PIA is probably not
       suitable for use on slow CPU's with limited memory, such as are typical
       in many embedded applications.  It <em>is</em> suitable for high-end
       systems that are capable of supporting a JVM, and is highly suitable
       for rapid prototyping of web-based interfaces which can then be
       re-implemented using other techniques.

</ul>


<p>

<hr>
<b>Copyright &copy; 1999 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
<address><a href="http://rsv.ricoh.com/~steve/"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com"
         >steve@rsv.ricoh.com</a>&gt;</address>
</body></html>
