<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>White Paper: Cross-Platform Web Applications with the PIA</title>
</head><body bgcolor="white" fgcolor="black"> 

<h2><a href="../index.shtml"><font face="Verdana, Arial, Helvetica, sans-serif"
    color="#993300">Ri</font><font face="Verdana, Arial, Helvetica, sans-serif"
    color="black"><i>Source.org</i></font></a>
/ <a href="index.html">White Papers</a>
/ Cross-Platform Web Applications with the PIA
</h2>

<h3>Foreword </h3>

<blockquote>
<p> <em>This White Paper is intended for developers of cross-platform web
    applications (loosely defined as software applications that computer
    applications that use the World Wide Web in significant ways, including as
    a data source or as a user interface, and that may be deployed in multiple
    software environments).  The <a href="http://RiSource.org/PIA/">PIA</a>
    provides a framework in which such applications can easily be developed.
    More information on the PIA approach to customizable web applications can
    be found in <a href="wp-webapp.html"> Web Applications and the PIA</a>.
</em></p>
</blockquote>

<h2><a name="contents">Table of Contents:</a></h2>

<hr />
<h3>Abstract</h3>

<p> <em>[will be sent in as a proposal to <a
    href="http://www9.org/w9-call-developer-extend.html">WWW9</a> Developer's
    Day XML track.]</em> 
</p>

<blockquote>
  <p> Major trends in web applications (computer applications that use the
      World Wide Web in significant ways, including as a data source or as a
      user interface) include: a proliferation of server platforms, clients,
      and development environments, increasing use of dynamic content,
      increasing use of XML, and increasing use of collaboration and
      customization as part both of the development process and of deployed
      applications.  One of the major consequences of these trends is an
      increasing need for <em>cross-platform</em> applications and development
      environments.
  </p>

  <p> The <a href="http://RiSource.org/PIA/">PIA</a> is an XML-based web
      application framework that is well-suited as a basis for developing and
      deploying cross-platform applications.  Some of the PIA's
      characteristics that support this include the PIA's reliance on XML as a
      single meta-syntax for both documents and processing, the use of
      standard API's (including SAX and DOM) for easy inclusion in existing
      XML applications, a small, portable core document-processing ``engine'',
      and an open-source reference implementation.
  </p>

  <p> The PIA can be seen as either an alternative or an adjunct to existing
      web application platforms, including those based on the XSLT
      transformation language, Java Server Pages, and Java Servlets.  The
      document-processing engine implements a complete programming language
      with XML syntax; it can be used <em>either</em> in a style-sheet-like
      mode with separate data and styles, or embedded in active documents.
      This allows it to fit easily into many different server platforms. 
  </p>

  <p> The PIA technology enables platform-independence in several ways.  It
      has a reference implementation in Java, which runs on any computing
      platform with a JVM.  The processing engine is simple, and easily ported
      to a wide range of different platforms.  And applications, which are
      written in XML, can be moved between platforms with no need for
      rewriting. 
  </p>

</blockquote>

<hr />
<h2>Trends in Web Applications and Development Environments</h2>

<blockquote>
<p> <em>In this paper we briefly mention those major trends in web
    applications that strongly imply a need for cross-platform applications
    and application development.  A more complete discussion can be found in a
    companion White Paper, <a href="wp-trends.html">Trends in Web
    Applications</a>.  </em>
</p>
</blockquote>

<h3>The Proliferation of Platforms</h3>

<p> The first major trend we will examine is the proliferation of platforms
    for deployment (servers), use (clients), and development of web
    applications.
</p>

<h4>Servers</h4>

<p> The number of server platforms on which one might consider running a web
    application is continuing to increase, as it has ever since the Web was
    created.  Although the <a href="http://www.netcraft.com/survey/">Netcraft
    Web Server Survey</a> shows that one web server, <a
    href="http://www.apache.org/">Apache</a>, has slightly over 50% of the
    market,  it still shows nine other servers used at over 60,000 sites
    each.  
</p>

<table align="center">
  <tr><th>Market Share for Top Servers Across All Domains</th></tr>
  <tr><td align="center">
         <img src="http://www.netcraft.com/Survey/Reports/199912/overallc.gif"
         alt="">
      </td>
  </tr>
  <tr><td align="right"><font size="-1">Source: <a
	href="http://www.netcraft.com/">Netcraft</a> Web Server Survey, <a
	href="http://www.netcraft.com/survey/"
	>http://www.netcraft.com/survey/</a>
      </td>
  </tr>
</table>


<p> In addition, this survey is somewhat misleading in two different ways.
    First, it groups servers together by vendor (so that the ``Microsoft''
    category, at nearly 25%, covers a total of five different server versions
    on several different operating systems).  Second, it covers only
    publicly-accessible web sites.  The second is the more important effect:
    the majority of web applications at the moment are <em>intranet</em>
    sites, hidden behind corporate firewalls.
</p>

<p> Moreover, ``traditional'' web servers are unlikely to dominate the field
    of web <em>applications</em> in the future, and indeed may not dominate
    even today.  Small web servers can now be found inside of a wide range of
    ``appliances'' including printers, scanners, routers, ethernet switches,
    and file servers.  Still others are specialized servers running on
    ordinary personal computers in order to ``web enable'' some attached
    peripheral such as a scanner or digital camera (``web-cam'').
</p>

<h4>Clients</h4>

<p> The web client field has not been dominated by a single browser since
    Microsoft started grabbing a significant market share away from Netscape.
    But even though these two currently make up most of the browser market,
    there are such significant differences between versions that the effective
    number of clients is increasing, not decreasing.  This trend is likely to
    continue, because new browsers like Opera continue to appear, and old
    standbys continue to be popular in niche markets (for example, visually
    handicapped users overwhelmingly prefer the text-based Lynx browser).
</p>

<p> Furthermore, as with servers, web browsers on personal computers represent
    a declining segment of a potentially huge market for web clients.  It is
    now possible to browse the web from a WebTV, a Palm Pilot or other PDA, an
    alphanumeric pager, or a cellular phone.  Web-enabled microwave ovens,
    refrigerators, and even dishwashers have been announced; such appliances
    are likely to include a web <em>server</em> as well, with the client doing
    double duty as web browser and front panel.
</p>

<p> The <a href="http://www.upsdell.com/BrowserNews/stat_browser.htm">Browser
    Trends</a> page at <a href="http://www.upsdell.com/BrowserNews">Browser
    News</a> shows a month-by-month history of browser usage since 1998.
</p>

<h4>Proxies</h4>

<p> An additional segment of the web application field that has gotten little
    attention so far is the proxy: an application that sits <em>between</em>
    client and server, performing some useful function.  Web caches, banner-ad
    eliminators, and ``parental choice'' filters all fall into this category;
    a huge number of users have used this kind of web application without
    knowing it (especially since AOL runs a proxy for all of its customers).
</p>

<p> In the future, we are likely to see an increase in the number of web
    applications that operate as proxies for performing a variety of
    <em>document processing</em> operations, including formatting, annotation,
    and content filtering.
</p>


<h4>Development Environments</h4>

<p> Unlike the platform arena, there has never been a single strong market
    leader in development environments for web applications.  Indeed, most
    applications are probably developed using a combination of text editors
    for code, and word processors for HTML documents.  A large amount of
    content, moreover, is <em>imported</em> from other environments, including
    databases and text files (for example, newswires, mailing lists, and
    Usenet news feeds).
</p>

<p> When we leave the <em>original</em> development environment and look at
    customization, however, the field is narrowed somewhat.  Probably most
    free text input on the web is done using HTML forms (for example, news
    items and comments submitted to <a
    href="http://slashdot.org/">Slashdot</a>).  Many sites include personal
    web pages, most of which are probably created using a browser. 
</p>

<p> With the advent of the WebDAV protocol, which allows ``distributed
    authoring'' by giving HTTP clients access to server-based files and
    metadata, it is likely that web applications with multiple developers will
    be developed using multiple tools, since each developer will be able to
    use their own favorite set.  Even without WebDAV, many applications
    (especially in the Open Source community) are developed using CVS and
    other server-based version-control systems. 
</p>

<p> Indeed, the line between dynamic content and the development environment
    is already getting rather fuzzy.  It is ``traditional'' to upload dynamic
    content to a server, and have it converted into HTML (possibly in several
    different styles) ``on the fly'' as it's being streamed out to the client.
    Bug content developers have access to the same stylesheet-based
    transformation tools at their desktops, so they could perform the style
    transformations once and upload the resulting <em>static</em> content,
    which would place less of a load on the server.  Then again, a
    sufficiently clever server could accomplish the same thing by caching.
</p>

<h2><em>[the web application space]</em></h2>

<em>[3-d plot of servers, OS's, clients, and web app. technologies]</em>


<h2>The need for Cross-Platform Applications</h2>

<p> One common thread among all of these trends is that the total market for
    web application platforms and development environments is growing far
    faster than the market share of any one participant.  ``Traditional''
    platforms in these areas, such as Unix servers, personal computers, and
    word-processing applications are being marginalized by less visible but
    more numerous embedded applications.  Even among the traditional platforms
    no single vendor controls the market, although one could make a good case
    for open-source platforms predominating in all areas the near future (as
    they already do in servers).
</p>

<p> Another point to consider is that most web applications evolve over time,
    and may involve many developers, content contributors, customizers, and
    collaborators.  Not only will these contributors all be using different
    development platforms, but the application may have to be ported from its
    original <em>server</em> platform to another.  This may happen because of
    inadequate performance, software or hardware obsolescence, or external
    factors such as corporate mergers or standardization decisions.
</p>

<p> Web applications have moved away from the simple world of static documents
    being passed from server to browser, toward more dynamic systems in which
    operations are performed on documents in all components of the system.
    Increasingly these dynamic systems are using XML as a <em>lingua
    franca</em>, representing tranditional documents, data, configuration
    files, and style transformations using a single easily-processed syntax.
</p>

<p> Clearly, wise web developers will want to keep their options open, which
    means using technologies that are as platform-neutral as possible.
    Fortunately, the increasing use of XML provides the means.  Because XML
    is, itself, completely platform-neutral, any application that can be
    specified entirely in XML will be platform-neutral as well.
</p>

<p> Another reason for platform-neutrality is that a single application may
    need to be deployed on multiple platforms from the beginning.  A web
    application is not necessarily a public web site -- most are intranet
    servers, and an increasing number are merely programs that run on desktop
    computers.  Anyone developing one of these applications may well want to
    sell it to more than one customer, and even to customers running a wide
    range of operating systems and servers.
</p>

<p> The argument for platform neutrality also applies -- rather strongly -- to
    consultants who develop web sites and web applications under contract.
    There is, of course, no way to control what the customer's platform of
    choice will be: the only options are to be platform neutral or to
    artificially restrict one's potential clientele.
</p>

<hr />
<h2>Web Applications: an Overview</h2>

<em>
The usual processing diagram, showing tagsets and documents.<br />

Starting points for figures can be found in
<a href="file:/pia1/pia/Doc/Slides/review97/Figures/"
>/pia1/pia/Doc/Slides/review97/Figures/</a>.  I could have sworn that we had
better ones, but it looks like we haven't been keeping up.<br />
</em>

<h3>Moving a Web Application</h3>

<h4>The General Case</h4>

<p> In general, a web application consists of several components; some are
    much easier to move between platforms than others:
</p>

<ul>
  <li> <strong>Static documents:</strong>  these are inherently
       platform-independent.  Unfortunately, their <em>names</em> may not be. 
  </li>
  <li> <strong>Site Structure:</strong> Filenames and other aspects of a
       site's structure can vary in several ways among platforms:
       <ol>
	 <li> <strong>File Types:</strong> different platforms have different
	      ways of indicating the MIME type of a document.  For example,
	      Unix normally uses an extension of <code>.html</code> to
	      indicate a <code>text/html</code> document; Windows uses
	      <code>.htm</code>.  MacOS uses a file type stored in the file's
	      resource fork.
	 </li>
	 <li> <strong>Case Sensitivity:</strong> Unix filenames are case
	      sensitive.  It is possible to distinguish, for example,
	      <code>Polish.html</code> and <code>polish.html</code>.  On other
	      operating systems one of these documents would have to be
	      renamed. 
	 </li>
	 <li> <strong>Name Length:</strong> Most modern operating systems
	      permit long names for files, but many older systems do not.  DOS
	      is notorious for its ``8+3'' limitation; it also had a
	      limitation on <em>depth</em> (the length of a pathname) which
	      Windows 95 does its best to conceal from the user.
	 </li>
	 <li> <strong>Character Set:</strong> Operating systems differ in the
	      set of characters permitted in filenames.  Letters, digits, and
	      hyphens are safe. 
	 </li>
       </ol>

       By planning ahead it is possible to avoid many of these problems.  As
       well as avoiding unusual characters and case sensitivity in filenames,
       it is usually possible to avoid exposing filename extensions to
       the client.  This can be done either by having the server select an
       appropriate extension based on content negotiation, or by using 
       directories as ``documents'' with the actual content in, e.g., the
       directory's <code>index.html</code> file.
  </li>
  <li> <strong>Active Documents:</strong> The most important documents in a
       web application (as opposed to a simple web site) are the active ones:
       the documents that do the work.  These include both CGI scripts and,
       more recently, documents with embedded code such as HHP3, ASP and JSP.
       When moving an application to a different platform, these active
       documents often have to be translated.  At least, some of the more
       common scripting languages and document formats are operating-system
       independent: a CGI script written in PERL or Python will usually be
       fairly portable.
  </li>
  <li> <strong>Server Features:</strong> Many, perhaps most, web servers have
       special features that an application may make use of.  Different
       servers may have different ways of keeping names and passwords for
       authentication, for example.  Some, such as Apache, may perform URL
       rewriting or invisible proxying.  Almost all modern servers have an API
       that allows efficient calls to code in some underlying programming
       language (C, Java, etc.).  These code modules are far more efficient
       than separate CGI scripts, but are also far less portable.
  </li>
  <li> <strong>Operating Environment:</strong> Some web applications interact
       strongly with their underlying operating systems and applications.
       Active documents running on a Microsoft platform can use COM to obtain
       services from standard applications; CGI scripts on Unix can use a
       command line for the same purpose. 
  </li>
</ul>

<h4>Moving a PIA Application</h4>

<p> The structure of the PIA makes it particularly easy to move an application
    from one platform to another.  Because the only non-XML components of a
    typical PIA application are the processing engine and the low-level or
    ``primitive'' tag handlers, the worst case is that this small amount of
    code may have to be rewritten to fit into the new platform.
</p>

<p> The <em>usual</em> case is much better, because the PIA's document
    processor and tag handlers are already written in popular programming
    languages (Java and C) using standard interfaces (SAX and DOM), and so are
    already able to fit in to the most popular web application platforms.
    This means that porting a <em>typical</em> application may only involve
    rewriting a few custom tag handlers (perhaps with operating system
    dependencies) and possibly translating the application's configuration
    files. 
</p>

<p> Portability of document names and site structure are not a significant
    problem with ``pure'' PIA applications because the PIA's site
    configuration mechanism encourages the use of names without extensions,
    and allows arbitrary mapping of URL's onto files and directories.  This
    means that an application's files and directories can be renamed to fit
    the platform without changing the URL's exposed to the clients.  Moving
    a PIA application to a platform that doesn't include the PIA's site
    configuration package is fairly simple in platforms like Apache that
    include a URL rewriting mechanism.
</p>

<hr />
<h2>The PIA Web Application Framework</h2>

<h3>PIA-based Web Applications</h3>

<p> The PIA is primarily designed for web applications that are
    ``document-oriented'' -- both the ``content'' or data, and the processing
    instructions (including so-called ``business rules'' as well as
    stylesheets and ``macros'') are represented as XML documents.  The PIA is
    also server-based: all of its processing is done on the application's
    server.
</p>

<blockquote>
  <p> We note in passing that the fact that the PIA does its document
      processing on the server in no way prevents active documents, including
      Cascading Style Sheets, Javascript and Java applets, from being passed
      to a browser client where appropriate.  It <em>does</em> mean that
      ``stylesheet'' processing </em>can<em> be done entirely on the server,
      making an application accessible from <em>any</em> browser.
  </p>
</blockquote>

<p> The point is worth emphasizing: a PIA web application consists
    <em>entirely</em> of XML and HTML documents, except for the
    document-processing ``engine'' that interprets the processing
    instructions.  Using server-side XML to build a web application has a
    number of advantages:
</p>

<ul>
  <li> XML is a widely-accepted standard.  XML files are easily ported between
       platforms and shared among applications.
  </li>
  <li> Because processing takes place on the server side, all the browser
       needs to see is ordinary HTML (customized, if necessary, for the
       particular client).
  </li>
  <li> Because XML files are simply documents with a standardized format, the
       same file can be processed in several different ways.  This can be
       used to make a site index or a ``what's new'' list, or to improve
       interoperability with other sites (for example, many news sites
       maintain an XML file with the day's headlines, for the benefit of
       portal sites).
  </li>
</ul>


<h3>A Platform-Independent Web Application Framework</h3>

<p> The PIA's particular XML processing engine has a few additional
    advantages: 
</p>

<ul>
  <li> It provides a complete set of processing operations, represented as XML
       ``tags,'' rather than providing a limited set (e.g. the
       tree-transformation operations of XSLT) or relying on ``escapes'' into
       another language (as do JSP, PHP, and others).  This means that PIA
       applications can be developed using any XML-aware development
       environment. 
  </li>
  <li> The mapping from tags to processing operations is completely defined by
       a document, called a ``tagset,'' that is completely separate from the
       document being processed.  Limiting the operations available when
       processing a document gives a simple but very effective form of
       security that can be especially useful in applications that allow users
       to upload or create documents.
  </li>
  <li> Unlike some other systems that are <em>purely</em> XML, the PIA is
       capable of processing ordinary HTML documents, optionally with a few
       XML tags embedded in them as extensions.  This makes it easier to
       incorporate ``legacy'' HTML documents into a primarily XML-based
       application.  HTML documents are also easier for users to create using
       simple text editors, which makes PIA-based applications easier to
       customize in a world that is not yet entirely ``XML-ready.''
  </li>
  <li> Because the processing engine itself is simple, and the set of
       basic processing operations is small, the PIA's document processing
       engine is easily ported to various server platforms.
  </li>
  <li> The reference implementation is written in Java, which is itself
       platform-neutral. 
  </li>
</ul>

<p> The PIA application platform also provides some additional functionality
    beyond the simple XML-based document-processing engine:
</p>

<ul>
  <li> The PIA includes a web server engine (written in Java) that allows
       ``agents'' written in XML to operate on HTTP requests and responses.
       This can be useful when writing proxy-based applications.  The build-in
       server is also useful for testing web applications.
  </li>
  <li> The PIA also includes an extremely versatile scheme for defining the
       structure of a web site, using XML description files.
  </li>
</ul>

<h2>The PIA and Other Platforms</h2>

<blockquote><em>
  A detailed discussion of the relationship between the PIA and other web
  technologies, including standards and protocols, can be found in
  <a href="wp-webapp.html#15">Web Applications and the PIA</a>.  In this
  section, we discuss making the PIA interoperate with other application
  platforms. 
</em></blockquote>

<p> Because of its implementation, the PIA's document-processing engine (and
    to a lesser extent its site-description mechanism) are particularly easy
    to incorporate into other web application platforms.  This makes it
    possible to build mixed systems that satisfy requirements (e.g. for
    performance or interoperability) that cannot easily be met by the PIA
    alone.  It also makes it easy to fit the PIA into existing systems, adding
    new capabilities without forcing a change of platform.
</p>

<h3>Java-based Systems</h3>

<p> Since the PIA's reference implementation is written in Java, and since it
    uses standard API's internally, it is easily incorporated into other
    Java-based application platforms.
</p>

<h4>Servlet engines</h4>

<p> The most common Java-based application platforms are web servers that use
    the Servlet (<code><a
    href="http://www.javasoft.com/products/servlet/2.2/javadoc/index.html"
    >javax.servlet</a></code> package) API.  Servlets provide a standard
    internal interface between a web server and Java code, and are a natural
    fit to the PIA. 
</p>

<p> The PIA provides two different Servlet implementations:
</p>

<ol>
  <li> A simple servlet that simply processes an input file using the PIA's
       document processing system.  This can be used to embed PIA processing
       in an existing static website or servlet-based application
  </li>
  <li> A more elaborate servlet that supports the PIA's site description
       mechanism as well.  This can be used to ``wrap'' an entire PIA-based
       application inside an existing servlet engine.
  </li>
</ol>

<h4>Cocoon</h4>

<p> <a href="http://xml.apache.org/cocoon/">Cocoon</a> is a pure-XML engine
    based on XML-to-XML transformation engines called ``processors.''  The
    standard Processor in Cocoon is an implementation of the XML
    tree-transformation stylesheet language XSLT.  The PIA's document
    processor fits naturally into the Cocoon environment.
</p>


<h4>SAX- and DOM-based systems</h4>

<p> There are two main interfaces used in Java for manipulating XML and HTML
    files: 
</p>

<ol>
  <li> DOM (the Document Object Model) is a set of standardized interfaces by
       which an application can access a document's parse tree.  The PIA uses
       an extended implementation of the DOM as its internal representation,
       (as does Cocoon, in fact), making it particularly simple to interface
       to DOM-based applications. 
  </li>
  <li> SAX (Simple API for XML) is an ``event-driven'' interface, in which a
       simple parser (the ``driver'') calls a method on the application class
       for each ``event'' -- a block of text or the start or end of a tagged
       element.  The PIA's document processor can function as either a SAX
       driver <em>or</em> a SAX application (or both), so it can easily be
       ``spliced in'' to an existing SAX tool chain.
  </li>
</ol>

<h3>C-based systems</h3>

<p> C is still by far the most widespread, most portable, and most completely
    standardized programming language currently in use.  It is particularly
    common to find a C compiler, and very little else, on the small or unusual
    processors used in embedded systems.  Also, many major pieces of software
    are written in C; in particular, the <a href="http://www.apache.org/"
    >Apache</a> web server.
</p>

<p> In order to better integrate with Apache, and in order to better serve the
    embedded system and network appliance markets, we have started an effort
    to re-implement the PIA's document processor in C.  In addition to
    improved interoperability, we expect this implementation to have
    <em>substantially</em> better performance than the Java version.
</p>

<p> Since Apache dominates the server market, with almost 60% of the installed
    base, we consider integration into Apache particularly important for the
    PIA.
</p>

<h3>Systems of Cooperating Servers</h3>

<p> Some servers, notably Apache, have the ability to invisibly route or proxy
    selected URL's to another server.  In fact, this ability is used inside
    Apache for its interfaces to Java and PERL.  It requires only a single
    line in Apache's configuration file, plus two parameters in the PIA's
    configuration file, to use the PIA in this mode.
</p>

<p> One advantage of using the PIA ``inside'' another server is that static
    pages can usually be served more efficiently by the other server.  Another
    is that a server such as Apache can provide services, such as virtual
    hosting and access to privileged ports, that are difficult for the PIA.
</p>

<blockquote>
  <p> One example is access to privileged ports, including port 80.  On Unix
      machines, only the ``superuser'' can access port 80, so a web server is
      expected to be started by the superuser and to change its user ID,
      typically to something safe like ``<code>nobody</code>,'' after opening
      its port.  Doing this in Java requires a non-portable native method.  It
      was far simpler to start the PIA under its own user ID and let Apache
      ``front'' for it.
  </p>
</blockquote>

<hr />
<p>
<b>Copyright &copy; 2000 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
<address><a href="http://rsv.ricoh.com/~steve/">Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com">steve@rsv.ricoh.com</a>&gt;</address>
</p>
</body></html>
