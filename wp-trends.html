<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>White Paper: Trends in Web Applications</title>
</head><body bgcolor="white" fgcolor="black"> 

<h2><a href="../index.shtml"><font face="Verdana, Arial, Helvetica, sans-serif" color="#993300">Ri</font><font face="Verdana, Arial, Helvetica, sans-serif" color="black"><i>Source.org</i></font></a>
/ <a href="index.html">White Papers</a>
/ Trends in Web Applications
</h2>

<h3>Foreword </h3>

<blockquote>
  <p> <em>This White Paper is intended for developers of web applications --
    loosely defined as software applications that are meant to be used with a
    web browser as their primary user interface.  In it, we examine current
    trends in web applications and their development, and describe how the <a
    href="http://RiSource.org/PIA/">PIA</a> responds to these trends and the
    requirements generated by those trends.  More information on the PIA
    approach to customizable web applications can be found in <a
    href="wp-webapp.html"> Web Applications and the PIA</a>. </em>
</p>
</blockquote>

<h2><a name="contents">Table of Contents:</a></h2>

<hr />
<h3>Abstract</h3>
<blockquote>
<p>

</p>

</blockquote>

<hr />
<h1>Part I:  Trends in Web Applications</h1>

<em>might actually want to separate applications and development</em>

<pre>
Trends:

  content-oriented (document-oriented) systems

  proliferation of platforms

  proliferation of clients

	This is one market Microsoft does not dominate, and never will.  It's
	true that MSIE has somewhat more than 50% of the PC browser market at
	the moment, but there are getting to be a lot of Palm Pilots and
	WebTV's out there.

  Shifting balance between client and server

	The days of helper applications are waning, and even Java may be on
	the decline.  Javascript is a standardization nightmare.  Stylesheets
	work, but they're (quite correctly) limited to style transformations.

	On the other hand, Moore's Law means that PC's are getting cheaper,
	faster, and more capable.  Applications must be capable of functioning
	with the entire range of clients, from stupid to brilliant.

	Similarly, although authors like having control over their content,
	readers like having control over the presentation (including fonts and
	formatting). 

  proliferation of development environments

  increasing use of XML

  increasing use of dynamic content

    increasing integration of code and content

	  many systems embed code in the content: ASP, PHP3, JSP, ...

    increasing separation of code and content

	  other systems go in the other direction; XSLT allows total separation
	  of the data and the documents that describe how to format the data.

    Decreasing reliance on ``raw code''.

	  The functionality is in active documents, not traditional programs
	  with embedded string constants. 

  increasing use of proxies for document transformation and manipulation

	not just caches.  Proxy-style apps are being used on the client side
	(i.e. close to the browser) for things like ad elimination.

  increasing use of collaboration and customization

	content comes from many people with many skill levels and different
	preferred tools (cf. Wiki-Wiki-Web and Slashdot)

	eventually this will include behavior as well.


<h3>The Changing Nature of Web Applications</h3>

<pre>
  Shifting balance between client and server

	The days of helper applications are waning, and even Java may be on
	the decline.  Javascript is a standardization nightmare.  Stylesheets
	work, but they're (quite correctly) limited to style transformations.

	On the other hand, Moore's Law means that PC's are getting cheaper,
	faster, and more capable.  Applications must be capable of functioning
	with the entire range of clients, from stupid to brilliant.

	Similarly, although authors like having control over their content,
	readers like having control over the presentation (including fonts and
	formatting). 

  content-oriented (document-oriented) systems

    increasing use of XML

    increasing use of dynamic content

    increasing integration of code and content

	  many systems embed code in the content: ASP, PHP3, JSP, ...

    increasing separation of code and content

	  other systems go in the other direction; XSLT allows total separation
	  of the data and the documents that describe how to format the data.

    Decreasing reliance on ``raw code''.

	  The functionality is in active documents, not traditional programs
	  with embedded string constants. 
</pre>

<h3>The Changing Nature of the Development Process</h3>

<pre>
  Shifting balance between developers and users

	increasing use of customization.

  increasing use of collaboration and customization

	content comes from many people with many skill levels and different
	preferred tools (cf. Wiki-Wiki-Web and Slashdot)

	eventually this will include behavior as well.

</pre>

Requirements for web applications:

  cross-platform

	The application should not be tied to a specific platform (server +
	processing engine) because performance and interoperability
	requirements change. 

  client-neutral

	An application may be used from any kind of client, from the latest
	game-oriented PC to a palmtop or cell phone.  The range of possible
	clients is expanding, not contracting.

  scalable

  stable interfaces

	Document types (e.g. file extensions) should be hidden from the
	client.  This allows the internal representation of documents to be
	changed as needed, without exposing the changes to the clients. 

	See <a href="http://www.w3.org/Provider/Style/URI">http://www.w3.org/Provider/Style/URI</a>

  customizable


Requirements for a web application development environment:

  [support a wide range of developer skill levels]

	The need for customizability means that the system must support
	developement by people with a wide range of skill levels.  In
	particular, both naive and expert developers must <em>both</em> be
	supported.

    Technical support

    Social Support

  document-oriented [support XML and other markup languages]

  platform neutral

  tool neutral

     aggregated, not integrated

	along with tool neutrality comes the additional requirement that
	developers should be able to add new, often specialized, tools to the
	development environment. 

     human-readable source / format-preserving tools

	Since document editing and transformation are fundamental to the
	development process, and since documents may be processed using
	different tools by different people, it's important that tools not
	alter the documents to the point where they're no longer recognizable
	by their authors.

  distributed

	Development teams are often geographically distributed; they need to
	be able to operate on the same document and code base, using shared
	version control, no matter where they are.


Fundamental Principles of Web Application Design:

	<em>It's problematic just what pieces of this belong here and what
	pieces in Part II or III.</em>

  Applications are collections of active documents

	This is fundamental.  The same documents can be treated as data and as
	processing instructions at different points in the system. 

  Separable Semantics

	This is also fundamental:  the semantics of all the tags (syntactic
	constructs) in a document is imposed by the tagset.  But it doesn't
	<em>have</em> to be separate, because one can just as easily impose
	the standard behavior on the standard tags, and so embed processing
	in a document where it makes sense to do so.

  One meta-syntax for documents and processing

	Syntax is something of a red herring: parsers can easily be written to
	translate between any input syntax and a DOM representation, and to
	render that representation into any output format.  The real point is
	that XML has a particularly simple and natural mapping to the
	underlying <em>meta</em>-syntax representation as a parse tree.

  No file extensions in URL's

	Because the site package permits (indeed encourages) URL's without
	file extensions (.html, etc.) it is possible to make major changes in
	a site's organization without changing the users' bookmarks.
</pre>

<hr />
<h1>Part II:  PIA Basic Principles</h1>

	<em>this part probably ought to have sub-sections that parallel the
	structure of part I. </em>
<pre>
Platform Independence

  The PIA technology is platform-independent in four different ways:

    1. Because it's written in Java, it can run out-of-the-box on any
       computing platform with a JVM.

    2. Because the modules are easily separated, they can be incorporated
       into many different kinds of web applications, using a variety of
       different toolsets.

    3. Because it is fairly simple, it is easily ported to different
       programming languages.

    4. Because it is based on widespread standard formats (XML) and protocols
       (HTTP), it has no dependence on the runtime environment or operating
       system. 

  A language without a parser.

    Because the DPS defines only the semantics of a few primitives, and no
    syntax, it is easily ported to different platforms.

  Flexible plumbing

    Because the DPS has both push (SAX), pull, and tree (DOM) inputs and
    outputs, it is easily incorporated into a wide range of tool chains and
    applications.

  Versatile structuring

    The site package allows an extremely wide range of structures for the site
    itself, independent of the underlying operating system.  (For example, the
    site package provides symbolic links and overlays even if the OS doesn't.)

Scalability

  Simplicity -> portability

    The PIA's simplicity makes it easy to port to different programming
    languages.  Speed/size trade-offs can be made in either direction over a
    wide range.

  Low memory requirements

    The PIA never needs to keep an entire document in memory, so it is easily
    scaled to handle large documents on small machines.

  Modularity -> separability 


<pre>
  Fundamental principles:

    Applications are collections of active documents

	This is fundamental.  The same documents can be treated as data and as
	processing instructions at different points in the system. 

    Separable Semantics

	This is also fundamental:  the semantics of all the tags (syntactic
	constructs) in a document is imposed by the tagset.  But it doesn't
	<em>have</em> to be separate, because one can just as easily impose
	the standard behavior on the standard tags, and so embed processing
	in a document where it makes sense to do so.

    One meta-syntax for documents and processing

	Syntax is something of a red herring: parsers can easily be written to
	translate between any input syntax and a DOM representation, and to
	render that representation into any output format.  The real point is
	that XML has a particularly simple and natural mapping to the
	underlying <em>meta</em>-syntax representation as a parse tree.

    No file extensions in URL's

	Because the site package permits (indeed encourages) URL's without
	file extensions (.html, etc.) it is possible to make major changes in
	a site's organization without changing the users' bookmarks.

  Secondary Effects:

    Platform Independence

	Because the underlying components of the PIA are platform-independent,
	it is possible to combine the PIA with whatever additional components
	are required, and run the result on whatever platform makes sense.

    Scalability

	Platform independence, in turn, leads to scalability because
	applications are easily ported between platforms. 

    Optimization 

	Because of the lack of extensions, processing can be done offline (or
	not), and CGI's, servlets, or alternative representations can be
	substituted for documents as needed.

    Customizability

	Because of the single meta-syntax, all aspects of an application can
	be easily customized by end users.  The separability of processing and
	documents makes this safe -- operations that mustn't be tampered with
	can be isolated in tagsets. 

</pre>


<hr />
<p>
<b>Copyright &copy; 2000 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
<address><a href="http://rsv.ricoh.com/~steve/">Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com">steve@rsv.ricoh.com</a>&gt;</address>
</p>
</body></html>
